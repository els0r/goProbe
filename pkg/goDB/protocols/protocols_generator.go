//go:build ignore
// +build ignore

// The make_protocols program is run by go generate to compile a OS specific
// list of IP protocols for forward and reverse lookup
package main

import (
	"bufio"
	"bytes"
	"fmt"
	"go/format"
	"os"
	"runtime"
	"sort"
	"strconv"
	"strings"
)

const (
	protocolsFile = "/etc/protocols"
)

func main() {

	protocols, err := readProtocols()
	if err != nil {
		fmt.Printf("failed to read IP protocols: %s\n", err)
		os.Exit(1)
	}

	if err := generateOutput(protocols); err != nil {
		fmt.Printf("failed to generate code: %s\n", err)
		os.Exit(1)
	}
}

type proto struct {
	name string
	id   int
}

// readProtocols loads contents of /etc/protocols into protocols map
// for quick access.
func readProtocols() (protoList []proto, err error) {
	file, err := os.Open(protocolsFile)
	if err != nil {
		return nil, err
	}
	defer func() {
		if cerr := file.Close(); err == nil && cerr != nil {
			err = cerr
		}
	}()

	// auxiliary to filter out duplicates
	var seen = make(map[string]struct{})

	protoList = make([]proto, 256)
	fileScanner := bufio.NewScanner(file)
	for fileScanner.Scan() {

		line := fileScanner.Text()
		if strings.HasPrefix(line, "#") {
			continue
		}

		fields := strings.Fields(line)
		if len(fields) < 3 {
			continue
		}

		protoID, err := strconv.ParseInt(fields[1], 10, 64)
		if err != nil {
			continue
		}

		// discard any id that's greater than 255. It would be invalid during the
		// cast to uint8 anyways
		if protoID > 255 {
			continue
		}

		p := proto{
			name: fields[2],
			id:   int(protoID),
		}

		_, exists := seen[p.name]
		if !exists {
			protoList = append(protoList, p)
			seen[p.name] = struct{}{}
		}
	}

	protoList = append(protoList, proto{name: "UNKNOWN", id: 255})

	return
}

func generateOutput(protoList []proto) error {

	buffer := bytes.NewBuffer(nil)

	fmt.Fprintf(buffer, `//go:build %s
// +build %s

// Code generated by protocols_generator.go - DO NOT EDIT.
`, runtime.GOOS, runtime.GOOS)

	fmt.Fprintln(buffer, `package protocols

// IPProtocols stores the IP protocol mappings to friendly name
var IPProtocols = map[int]string{`)

	// sort by id
	sort.SliceStable(protoList, func(i, j int) bool {
		return protoList[i].id < protoList[j].id
	})

	for _, proto := range protoList {
		if proto.name != "" {
			fmt.Fprintf(buffer, "\t%d:\t\t\"%s\",\n", proto.id, proto.name)
		}
	}

	fmt.Fprintln(buffer, `}

// IPProtocolIDs is the reverse mapping from friendly name to protocol number
var IPProtocolIDs = map[string]int{`)

	// sort by name now
	sort.SliceStable(protoList, func(i, j int) bool {
		return strings.ToLower(protoList[i].name) < strings.ToLower(protoList[j].name)
	})

	for _, proto := range protoList {
		if proto.name != "" {
			fmt.Fprintf(buffer, "\t\"%s\":\t\t%d,\n", strings.ToLower(proto.name), proto.id)
		}
	}

	fmt.Fprintln(buffer, `}`)

	// Format the code
	fmtContent, err := format.Source(buffer.Bytes())
	if err != nil {
		return err
	}

	return os.WriteFile("protocols_"+runtime.GOOS+".go", fmtContent, 0600)
}
