//go:build ignore
// +build ignore

// The make_protocols program is run by go generate to compile a OS specific
// list of IP protocols for forward and reverse lookup
package main

import (
	"bufio"
	"bytes"
	"fmt"
	"go/format"
	"os"
	"runtime"
	"sort"
	"strconv"
	"strings"
)

const (
	protocolsFile = "/etc/protocols"
)

func main() {

	protocols, err := readProtocols()
	if err != nil {
		fmt.Printf("failed to read IP protocols: %s\n", err)
		os.Exit(1)
	}

	if err := generateOutput(protocols); err != nil {
		fmt.Printf("failed to generate code: %s\n", err)
		os.Exit(1)
	}
}

// readProtocols loads contents of /etc/protocols into protocols map
// for quick access.
func readProtocols() (protoList []string, err error) {
	file, err := os.Open(protocolsFile)
	if err != nil {
		return nil, err
	}
	defer func() {
		if cerr := file.Close(); err == nil && cerr != nil {
			err = cerr
		}
	}()

	// auxiliary to filter out duplicates
	var seen = make(map[string]struct{})

	protoList = make([]string, 256)
	fileScanner := bufio.NewScanner(file)
	for fileScanner.Scan() {

		line := fileScanner.Text()
		if strings.HasPrefix(line, "#") {
			continue
		}

		fields := strings.Fields(line)
		if len(fields) < 3 {
			continue
		}

		protoID, err := strconv.ParseInt(fields[1], 10, 64)
		if err != nil {
			continue
		}

		_, exists := seen[fields[2]]
		if !exists {
			protoList[protoID] = fields[2]
			seen[fields[2]] = struct{}{}
		}
	}

	protoList[255] = "UNKNOWN"

	return
}

func generateOutput(protoList []string) error {

	buffer := bytes.NewBuffer(nil)

	fmt.Fprintf(buffer, `//go:build %s
// +build %s

// Code generated by protocols_generator.go - DO NOT EDIT.
`, runtime.GOOS, runtime.GOOS)

	fmt.Fprintln(buffer, `package protocols

// IPProtocols stores the IP protocol mappings to friendly name
var IPProtocols = map[int]string{`)

	for protoID, protoName := range protoList {
		if protoName != "" {
			fmt.Fprintf(buffer, "\t%d:\t\t\"%s\",\n", protoID, protoName)
		}
	}

	fmt.Fprintln(buffer, `}

// IPProtocolIDs is the reverse mapping from friendly name to protocol number
var IPProtocolIDs = map[string]int{`)

	// sort by name now
	sort.SliceStable(protoList, func(i, j int) bool {
		return protoList[i] < protoList[j]
	})

	type proto struct {
		name string
		id   int
	}

	var protos = make([]proto, 0, len(protoList))
	for protoID, protoName := range protoList {
		if protoName != "" {
			protos = append(protos, proto{name: strings.ToLower(protoName), id: protoID})
		}
	}

	sort.SliceStable(protos, func(i, j int) bool {
		return protos[i].name < protos[j].name
	})

	for _, proto := range protos {
		fmt.Fprintf(buffer, "\t\"%s\":\t\t%d,\n", proto.name, proto.id)
	}

	fmt.Fprintln(buffer, `}`)

	// Format the code
	fmtContent, err := format.Source(buffer.Bytes())
	if err != nil {
		return err
	}

	return os.WriteFile("protocols_"+runtime.GOOS+".go", fmtContent, 0600)
}
